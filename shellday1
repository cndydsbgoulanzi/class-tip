shell day1 
如果真的想走IT这条路，想真正管理好你的主机，那么学习自动化管理工具Shell Scripts 非常重要！
就是将一些命令放在一起去执行，并且不需要编译就能执行，很方便，所以在日常工作中可以用shell scripts来简化我们的管理。可以但到我们linux中，很多服务的启动都是透过shell脚本来启动的。
如果你不会脚本，那么服务器出问题的时候，真的会求助无门，所以好好地学习吧！
----------------------------------------------------------------
1.shell的变量功能
	#什么是变量
		让一个特定的字符代表不固定的内容，有点像y=ax+b,y就是变量，
		用简单的字眼来代替比较复杂或者容易变动的数据，好处就是方便！
			比如系统中的MAIL和USER变量，根据当前登陆的用户而变化
		对脚本的用处——例如ule考试的评分脚本，根据你们的机器号的不同，去检测不同的学生考试成绩
	#变量的设置、查看和取消 echo unset
		查看	echo ${MAIL} 
			echo $MAIL
		设置	变量名=变量的内容
				myname=booboo
				myname="booboo wei"
			注意事项
				变量名可以是数字和字符，但是数字不可以放在最前面
				变量内容若有空格，可以使用单引号或者双引号
					双引号保留特殊字符原有属性
					单引号特殊字符变一般字符（纯文本）
					也可使用\跳脱字符将特殊字符变成一般字符
				`指令`或$(指令)可以将指令的结果变成变量内容
		取消	unset 变量名
				unset myname

		课堂练习：
			1.设置变量myname=superman并查看变量的值；
			2.设置变量myname1=I am superman
				myname2="I am superman"
				myname3='I am superman'并查看所有变量的值；
			3.设置两个变量分别为name1="$myname is myname"和name2='$myname is myname';并查看变量的值；
			4.设置变量kernel的值为当前系统的内核版本号；
			5.设置变量num的值为/etc/目录下所有以.conf结尾的文件的总数；
			6.取消练习中的有所变量。

	#变量内容的删除、和替换				
		变量设定方式		说明
		${变量#关键词}		若变量内容从头开始的数据符合『关键词』,则将符合的最短数据删除
		${变量##关键词} 		若变量内容从头开始的数据符合『关键词』,则将符合的最长数据删除
		${变量%关键词} 		若变量内容从尾向前的数据符合『关键词』,则将符合的最短数据删除
		${变量%%关键词}		若变量内容从尾向前的数据符合『关键词』,则将符合的最长数据删除
		${变量/旧字符串/新字符串} 	若变量内容符合『旧字符串』则『第一个旧字符串会被新字符串替换』
		${变量//旧字符串/新字符串}	若变量内容符合『旧字符串』则『全部的旧字符串会被新字符串替换』
		
		课堂练习：
			1.设置变量path=${PATH} 并查看；
			2.设置变量path=/batman/bin:${path}:/superman/bin 并查看；
			3.读取变量的时候将/batman/bin:及第一个冒号及之前的删除；
			4.读取变量的时候将最后一个冒号及之前的都删除；
			5.读取变量的时候将:/superman/bin及最后一个冒号及之后的删除；
			6.读取变量的时候将第一个冒号及之后的都删除；
			7.读取变量的时候将第一个sbin替换成SBIN；
			8.读取变量的时候将所有的sbin替换成SBIN；
			9.取消练习中的path变量。

	#变量的分类：本地变量和环境变量 env set export
			分类标准	变量是否会被子程序所继续引用；本地变量不会；环境变量会
			env 	列出目前shell环境下的所有环境变量
			set 	查看所有变量，包括环境变量和本地变量
			export	将本地变量转成环境变量	export myname
		课堂练习：
			1.打开一个终端bash，查看该终端的pid号；
			2.设置本地变量justice1="this is local"并查看;
			3.设置环境变量justice2="this is env"并查看;
			4.打开子终端bash，查看该终端的pid号和ppid号；
			5.在子终端中分别查看变量justice1和justice2的值；
	
	#变量读取、数组与宣告 read array declare 
		read	从键盘读取数据存入变量
			read -p "plz input yourname:" -t 30 name 按下回车输入变量name的值，会等待30s结束
		array	
			数组的设定	A[0]=1;A[1]=2;A[2]=3
					A=(1 2 3)
					A=(1 2 3 [50]=4)
					A=(1 2 3 [50]=4 5)
			数组的读取	echo ${A[0]}
					echo ${A[@]}
					echo ${A[*]} 
					* 代表的是一次取出所有的值 ,@ 代表依次取值
						for i in "$A[@]";do echo $i;done
						for i in "$A[*]";do echo $i;done
		declare
			declare 参数
				-a 将变量看成数组
				-i 将变量看成整数
				-r 使变量只读
			x=1
			y=2
			sum=$(($x+$y))
		课堂练习：
			1.用read命令从键盘读取num变量的值，提示语句为“请输入你的机器号：”，限时间20s；
			2.设置数组S 第一位为1，第二位为2，第三十位为4，第三十一位为5，读取数组所有的值，读取数组第二位；
			3.设置变量x=1，y=2，变量sum=$x+$y，查看sum的值；
			4.宣告变量x为整数型值为1，变量y为整数型值为2,变量sum为整数型=$x+$y，查看sum的值；

2.数据流重导向redirection
	#何谓数据流重导向
		指令执行后的结果有：	命令执行是否正确的返回值?	0正确；！0错误		简称	代码	符号
					命令执行输出的正确信息	standard output		stdout	1	>或者>>
					命令执行输出的错误信息	standard error output	stderr	2	2>或者2>>
		指令执行前的输入：		命令执行输入的信息		standard in		stdin	0	<或者<<
	
		用法总结			
			1> :以覆盖的方法将『正确的数据』输出到指定的文件中；
			1>>:以追加的方法将『正确的数据』输出到指定的文件中；
			2> :以覆盖的方法将『错误的数据』输出到指定的文件中；
			2>>:以追加的方法将『错误的数据』输出到指定的文件中；

		cat	从键盘读取数据存入文件
			cat > /tmp/catfile 以ctrl+d结束	
			cat > /tmp/catfile < /tmp/passwd
			cat > /tmp/catfile << ENDF
			standard in
			ENDF===>结束提示符
			
		课堂练习：
			1.查看系统/目录下的所有文件名和属性，并记录到/tmp/file文件中；
			2.查看系统/var/目录下的所有文件名和属性，并追加记录到/tmp/file文件中；
			3.切换到student用户，在/home目录下查找文件名为.bashrc的文件是否存在；
			4.切换到student用户，在/home目录下查找文件名为.bashrc的文件，将该命令执行输出的正确信息显示到屏幕上，将该命令执行输出的错误信息放到黑洞/dev/null中；
			5.切换到student用户，在/home目录下查找文件名为.bashrc的文件，将该命令执行输出的正确信息保存到/tmp/stdout文件中并查看，将该命令执行输出的错误信息放到黑洞/dev/null中；
			6.切换到student用户，在/home目录下查找文件名为.bashrc的文件，将该命令执行输出的正确信息保存到/tmp/stdout文件中，将该命令执行输出的错误信息保存到/tmp/stderr文件中，并查看；
			7.切换到student用户，在/home目录下查找文件名为.bashrc的文件，将该命令执行输出的所有信息（正确和错误）都保存到/tmp/all中，并查看；
			8.使用cat命令从键盘读取数据helloword并覆盖/tmp/catfile文件；
			9.使用cat命令将/etc/passwd/的内容覆盖/tmp/catfile文件；
			10.使用cat命令从键盘读取数据helloword并覆盖/tmp/catfile文件，以结束提示符的方式结束；
					 
	#命令执行的判断依据 ; && ||
		CMD1 && CMD2 	如果前一个命令 (CMD1) 能够正确被执行 , 则执行后一个命令 (CMD2)
		CMD1 || CMD2 	如果前一个命令 (CMD1) 被正确执行 , 则不执行后一个命令 (CMD2), 如果前一个命令(CMD1) 执行错误 , 则执行后一个命令 (CMD2).
		CMD1 ; CMD2	命令之间没有关系，从第一个开始执行，不管是否正确执行都会去执行第二个命令

		课堂实验：
			1.创建目录/tmp/cmd,如果创建成功那么就再创建一个目录/tmp/cmd/cdm1;
			2.创建目录/tmp/cmd,如果创建失败，那么就再船舰一个目录/tmp/cmd/cmd2;
			3.不管目录/tmp/cmd是否创建成功，都会去再创建一个目录/tmp/tmpcmd;
	
3.管道命令pipe
	#截取 grep cut
		grep bash$ /etc/passwd
		cut -d : -f 3 /etc/passwd
	#排序 sort uniq
		sort -t: -k3 -n /etc/passwd
	#统计 wc
		wc -l /etc/passwd
	#替换 xargs
		find /sbin/ -perm +7000|wc -l
		find /sbin/ -perm +7000|xargs wc -l
		课堂练习：
		1.找出/sbin/目录下有特殊权限的文件，并统计每个文件的行数
		2.找出/sbin/目录下有特殊权限的文件，并统计有几个

	#减号 -
		课堂练习：
		1.将/home目录打包压缩后解压到/tmp目录
4.shell下的特殊符号
	#	注释符
	\	跳脱符
	|	管道
	;	连续指令的下达
	~	家目录
	$	取用变量符
	&	进程控制后台运行
	!	逻辑运算非
	/	根目录
	>,>>	数据流重导向 输出
	<,<<	数据流重导向 输入
	''	特殊字符失效
	""	特殊字符有效
	``	命令执行的结果
	{}	命令的组合

=======================================================================================
SHELL SCRIPTS
1.shell 的基本组成元素
	1> 魔法字符 “ #! ”: 出现在脚本第一行 , 用于定义命令解释器。
	2> “ # ” 号开头的行 : 除了第一行的魔法字符以外 , 其他以 ” # “ 号开头 的行是注示。这些行不会被运行 , 只是给人阅读使用。
	3> 系统命令 :shell 脚本中运行解释的系统命令。
	4> 变量 : 脚本运行过程中某些反复调用的值的暂存地。
	5> 流程控制语句 : 判断 , 循环 , 跳转等流程控制。
2.执行脚本的方法
	1> bash 脚本名称 bash -x 以调试模式来运行脚本
	2> ./ 脚本名称 --> 需要对脚本有可执行的权限
3.shell的基本语法
• 条件判断语句 	if test
• 循环语句	for while unitl
• 其他流程控制 	case continue break shift function
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
# if 语法格式
	if condition	-->condition 指的是判断的条件
	then		
		CMD1	--> CMD1 指的是满足判断条件后执行的语句
	else
		CMD2	--> CMD2 指的是不满足判断条件执行的语句 then
	fi

	if condition
	then
		CMD1
	elif condition
		CMD2
	else
		CMD3
	fi
# 判断条件
	test 判断—————man test 查看的相关的判断指令
		
	数字的判断 	字符的判断 	文件的判断
	-gt 大于 	-z 空 		-d 文件是不是一个目录
	-ge 大于等于 	=  字符相等 	-f 是不是一个普通文件
	-lt 小于 	!= 字符不相等 	-e 文件是不是存在
	-le 小于等于 	-n 非空 	
	-ne 不等于 	-a 逻辑与 
	-eq 等于 	-o 逻辑或 
	
	注意 ：[ ] 括号两边有空格
	      判断符号两边有空格
	
#课堂练习：
	1.写一个脚本，判断用户是否存在，如果存在则删除。若不存在，就提示不存在。
	2.三个数字比大小，输出最大的
	3.三个数字比大小,并且按从大到小排列
	[ $a -gt $b ]
	[ -d $F ]

～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
# for 语法格式
	for 变量 in 取值范围
	do
		CMD
	done
# 取值范围
	以空格分割	for i in 1 2 3
	以{}罗列		{1..10}
	可以使用seq	$(seq 1 10)==>1 2 3 4 5 6 7 8 9 10
			`seq 1 10`
			seq 1 2 10==>1 3 5 7 9 
			seq 10 -1 1==>10 9 8 7 6 5 4 3 2 1
# 命令行方式 
	for i in {1..10};do echo $i;done
# 课堂练习
	4.画斜线正反
	5.达到如下效果
    *
   ***
  *****
 *******
*********
	6.写一个9*9乘法表
	7.画一个平行四边形

